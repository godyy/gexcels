package code

import (
	"github.com/godyy/gexcels"
	"github.com/godyy/gexcels/internal/utils"
	"github.com/godyy/gexcels/parse"
	pkg_errors "github.com/pkg/errors"
	"strings"
	"text/template"
)

// templateGoStruct go结构体模版
var templateGoStruct = template.Must(template.New("go_struct").
	Parse(`type {{.Exporter.GetStructName .Struct}} struct {
	{{range $index,$field := .Struct.Fields -}}
	{{if $index}}{{"\n"}}{{end -}}
	{{$.Exporter.GenStructField $field}}
	{{- end}}
}
`))

// GenStruct 生成结构体文本
func (e *goExporter) GenStruct(sd *parse.Struct) string {
	var sb strings.Builder
	if err := templateGoStruct.Execute(&sb, map[string]interface{}{
		"Exporter": e,
		"Struct":   sd,
	}); err != nil {
		panic(pkg_errors.WithMessage(err, "export code: go: GenStruct"))
	}
	return sb.String()
}

// templateGoStructsFile go结构体文件模版
var templateGoStructsFile = template.Must(template.New("go_structs_file").
	Parse(`// Code generated by gexcels; DO NOT EDIT.
// This file was automatically generated and may be overwritten.

package {{.PkgName}}

{{range $index, $struct := .Structs -}}
{{$structName := $.Exporter.GetStructName $struct -}}
{{if $index}}{{"\n"}}{{end -}}
// {{$structName}} {{$struct.Desc}}
{{$.Exporter.GenStruct $struct}}
{{- end}}
`))

// GenStructsFile 生成go结构体文件文本
func (e *goExporter) GenStructsFile() string {
	var sb strings.Builder
	if err := templateGoStructsFile.Execute(&sb, map[string]interface{}{
		"Exporter": e,
		"Structs":  e.parser.Structs,
		"PkgName":  e.kindOptions.PkgName,
	}); err != nil {
		panic(pkg_errors.WithMessage(err, "export code: go: GenStructsFile"))
	}
	return sb.String()
}

// templateGoEntryStruct go table结构体模版
var templateGoEntryStruct = template.Must(template.New("go_struct").
	Parse(`type {{.Exporter.GetEntryStructName .Table}} struct {
	{{range $index,$field := .Table.Fields -}}
	{{if $index}}{{"\n"}}{{end -}}
	{{$.Exporter.GetEntryFieldName $field}} {{$.Exporter.GetEntryFieldType $field}} {{$.Exporter.GenEntryFieldTag $field}} // {{$field.Desc}}
	{{- end}}
}`))

// GenEntryStruct 生成go配置表结构体文本
func (e *goExporter) GenEntryStruct(td *parse.Table) string {
	var sb strings.Builder
	if err := templateGoEntryStruct.Execute(&sb, map[string]interface{}{
		"Exporter": e,
		"Table":    td,
	}); err != nil {
		panic(pkg_errors.WithMessage(err, "export code: go: GenEntryStruct"))
	}
	return sb.String()
}

// templateGoTableUniqueKeyMethod go配置表唯一键方法模版
var templateGoTableUniqueKeyMethod = template.Must(template.New("go_table_unique_key_method").
	Parse(`{{$methodName := .Exporter.GenTableUniqueKeyMethodName .Field -}}
// {{$methodName}} mapping by {{.Exporter.GetEntryFieldName .Field}}
func (t *{{.Exporter.GetTableStructName .Table}}) {{$methodName}}({{.Field.Name}} {{.Exporter.GetEntryFieldType .Field}}) *{{.Exporter.GetEntryStructName .Table}} {
	return t.{{.Exporter.GetTableUniqueKeyFieldName .Field}}[{{.Field.Name}}]
}
`))

// GenTableUniqueKeyMethod 生成go配置表唯一键方法
func (e *goExporter) GenTableUniqueKeyMethod(td *parse.Table, field *gexcels.TableField) string {
	var sb strings.Builder
	if err := templateGoTableUniqueKeyMethod.Execute(&sb, map[string]interface{}{
		"Exporter": e,
		"Table":    td,
		"Field":    field,
	}); err != nil {
		panic(pkg_errors.WithMessage(err, "export code: go: GenTableUniqueKeyMethod"))
	}
	return sb.String()
}

// templateGoTableCompositeKeyMethod go配置表组合键方法模版
var templateGoTableCompositeKeyMethod = template.Must(template.New("go_table_composite_key_method").
	Funcs(template.FuncMap{
		"sub": func(a, b int) int { return a - b },
	}).
	Parse(`{{$methodName := .Exporter.GenTableCompositeKeyMethodName .CompositeKey -}}
// {{$methodName}} composite-key {{.CompositeKey.Name}}
func (t *{{.Exporter.GetTableStructName .Table}}) {{$methodName}} (
{{range $index, $fieldName := .CompositeKey.FieldNames -}}
{{if $index}}{{", "}}{{end}}{{$fieldName -}}
{{$field := $.Table.GetFieldByName $fieldName}} {{$.Exporter.GetEntryFieldType $field}}{{end -}}
) *{{.Exporter.GetEntryStructName .Table}} {
	{{$up := printf "t.%s" (.Exporter.GetTableCompositeKeyFieldName .CompositeKey) -}}
	{{$cur := "" -}}
	{{$lastField := "" -}}
	{{range $index, $fieldName := .CompositeKey.FieldNames -}}
	{{$lastField = $fieldName -}}
	{{$field := $.Table.GetFieldByName $fieldName -}}
	{{$cur = printf "by%s" ($.Exporter.GetEntryFieldName $field) -}}
	{{if lt $index (sub (len $.CompositeKey.FieldNames) 1) -}}
	{{if $index}} else {{end -}}
	if {{$cur}} := {{$up}}[{{$fieldName}}]; {{$cur}} == nil {
		{{$up = $cur -}}
		return nil
	}{{else}} else {
		return {{$up}}[{{$lastField}}]
	}{{end}}
	{{- end}}
}
`))

// GenTableCompositeKeyMethod 生成go配置表组合键方法
func (e *goExporter) GenTableCompositeKeyMethod(td *parse.Table, ck *parse.TableCompositeKey) string {
	var sb strings.Builder
	if err := templateGoTableCompositeKeyMethod.Execute(&sb, map[string]interface{}{
		"Exporter":     e,
		"Table":        td,
		"CompositeKey": ck,
	}); err != nil {
		panic(pkg_errors.WithMessage(err, "export code: go: GenTableCompositeKeyMethod"))
	}
	return sb.String()
}

// templateGoTableCompositeKeyInitMethod go配置表组合键初始化方法模版
var templateGoTableCompositeKeyInitMethod = template.Must(template.New("go_table_composite_key_field_init_method").
	Funcs(template.FuncMap{
		"add": func(a, b int) int { return a + b },
		"sub": func(a, b int) int { return a - b },
	}).Parse(`{{$methodName := .Exporter.GenTableCompositeKeyInitMethodName .CompositeKey -}}
// {{$methodName}} composite-key {{.CompositeKey.Name}}
func (t *{{.Exporter.GetTableStructName .Table}}) {{$methodName}}(e *{{.Exporter.GetEntryStructName .Table}}) {
	{{$lastIndex := sub (len .CompositeKey.FieldNames) 1 -}}
	{{$up := printf "t.%s" (.Exporter.GetTableCompositeKeyFieldName .CompositeKey) -}}
	{{$cur := "" -}}
	{{range $index, $fieldName := .CompositeKey.FieldNames -}}
	{{if eq $index $lastIndex}}{{break}}{{end -}}
	{{$field := $.Table.GetFieldByName $fieldName -}}
	{{$fieldExportName := $.Exporter.GetEntryFieldName $field -}}
	{{$cur = printf "by%s" $fieldExportName -}}
	{{$cur}} := {{$up}}[e.{{$fieldExportName}}]
	if {{$cur}} == nil {
		{{$cur}} = make({{$.Exporter.GenTableCompositeKeyFieldType $.Table (slice $.CompositeKey.FieldNames (add $index 1))}})
		{{$up}}[e.{{$fieldExportName}}] = {{$cur}}
	}
	{{$up = $cur}}
	{{- end}}
	{{- $lastField := .Table.GetFieldByName (index .CompositeKey.FieldNames $lastIndex)}}{{$cur}}[e.{{.Exporter.GetEntryFieldName $lastField}}] = e
}
`))

// GenTableCompositeKeyInitMethod 生成go配置表组合键初始化方法
func (e *goExporter) GenTableCompositeKeyInitMethod(td *parse.Table, ck *parse.TableCompositeKey) string {
	var sb strings.Builder
	if err := templateGoTableCompositeKeyInitMethod.Execute(&sb, map[string]interface{}{
		"Exporter":     e,
		"Table":        td,
		"CompositeKey": ck,
	}); err != nil {
		panic(pkg_errors.WithMessage(err, "export code: go: GenTableCompositeKeyInitMethod"))
	}
	return sb.String()
}

// templateGoTableGroupMethod go配置表分组方法模版
var templateGoTableGroupMethod = template.Must(template.New("go_table_group_method").
	Funcs(template.FuncMap{
		"sub": func(a, b int) int { return a - b },
	}).
	Parse(`{{$methodName := .Exporter.GenTableGroupMethodName .Group -}}
// {{$methodName}} group {{.Group.Name}}
func (t *{{.Exporter.GetTableStructName .Table}}) {{$methodName}} (
{{range $index, $fieldName := .Group.FieldNames -}}
{{if $index}}{{", "}}{{end}}{{$fieldName -}}
{{$field := $.Table.GetFieldByName $fieldName}} {{$.Exporter.GetEntryFieldType $field}}{{end -}}
) []*{{.Exporter.GetEntryStructName .Table}} {
	{{$up := printf "t.%s" (.Exporter.GetTableGroupFieldName .Group) -}}
	{{$cur := "" -}}
	{{$lastField := "" -}}
	{{range $index, $fieldName := .Group.FieldNames -}}
	{{$lastField = $fieldName -}}
	{{$field := $.Table.GetFieldByName $fieldName -}}
	{{$cur = printf "by%s" ($.Exporter.GetEntryFieldName $field) -}}
	{{if lt $index (sub (len $.Group.FieldNames) 1) -}}
	{{if $index}} else {{end -}}
	if {{$cur}} := {{$up}}[{{$fieldName}}]; {{$cur}} == nil {
		{{$up = $cur -}}
		return nil
	}{{else}} else {
		return {{$up}}[{{$lastField}}]
	}{{end}}
	{{- end}}
}
`))

// GenTableGroupMethod 生成go配置表分组方法
func (e *goExporter) GenTableGroupMethod(td *parse.Table, group *parse.TableGroup) string {
	var sb strings.Builder
	if err := templateGoTableGroupMethod.Execute(&sb, map[string]interface{}{
		"Exporter": e,
		"Table":    td,
		"Group":    group,
	}); err != nil {
		panic(pkg_errors.WithMessage(err, "export code: go: GenTableGroupMethod"))
	}
	return sb.String()
}

// templateGoTableGroupInitMethod go配置表分组初始化方法模版
var templateGoTableGroupInitMethod = template.Must(template.New("go_table_group_field_init_method").
	Funcs(template.FuncMap{
		"add": func(a, b int) int { return a + b },
		"sub": func(a, b int) int { return a - b },
	}).Parse(`{{$methodName := .Exporter.GenTableGroupInitMethodName .Group -}}
// {{$methodName}} group {{.Group.Name}}
func (t *{{.Exporter.GetTableStructName .Table}}) {{$methodName}}(e *{{.Exporter.GetEntryStructName .Table}}) {
	{{$lastIndex := sub (len .Group.FieldNames) 1 -}}
	{{$up := printf "t.%s" (.Exporter.GetTableGroupFieldName .Group) -}}
	{{$cur := "" -}}
	{{range $index, $fieldName := .Group.FieldNames -}}
	{{if eq $index $lastIndex}}{{break}}{{end -}}
	{{$field := $.Table.GetFieldByName $fieldName -}}
	{{$fieldExportName := $.Exporter.GetEntryFieldName $field -}}
	{{$cur = printf "by%s" $fieldExportName -}}
	{{$cur}} := {{$up}}[e.{{$fieldExportName}}]
	if {{$cur}} == nil {
		{{$cur}} = make({{$.Exporter.GenTableGroupFieldType $.Table (slice $.Group.FieldNames (add $index 1))}})
		{{$up}}[e.{{$fieldExportName}}] = {{$cur}}
	}
	{{$up = $cur}}
	{{- end}}
	{{- $lastField := .Table.GetFieldByName (index .Group.FieldNames $lastIndex) -}}
	{{$cur}}[e.{{.Exporter.GetEntryFieldName $lastField}}] = append({{$cur}}[e.{{.Exporter.GetEntryFieldName $lastField}}], e)
}
`))

// GenTableGroupInitMethod 生成go配置表分组初始化方法
func (e *goExporter) GenTableGroupInitMethod(td *parse.Table, group *parse.TableGroup) string {
	var sb strings.Builder
	if err := templateGoTableGroupInitMethod.Execute(&sb, map[string]interface{}{
		"Exporter": e,
		"Table":    td,
		"Group":    group,
	}); err != nil {
		panic(pkg_errors.WithMessage(err, "export code: go: GenTableGroupInitMethod"))
	}
	return sb.String()
}

// templateGoNormalTableFile go常规配置表文件模版
var templateGoNormalTableFile = template.Must(template.New("go_table_file").
	Parse(`// Code generated by gexcels; DO NOT EDIT.
// This file was automatically generated and may be overwritten.

package {{.PkgName}}

{{.Exporter.GenEntryStruct .Table}}

{{$entryStructName := .Exporter.GetEntryStructName .Table}}
{{$tableStructName := .Exporter.GetTableStructName .Table}}

// {{$tableStructName}} {{.Table.Desc}}
type {{$tableStructName}} struct {
	entries []*{{$entryStructName}} // data entries
	{{$hasUnique := false -}}
	{{range $index, $field := .Table.Fields -}}
	{{if $field.Unique -}}
	{{if $hasUnique}}{{"\n"}}{{end -}}
	{{$hasUnique = true -}}
	{{$.Exporter.GetTableUniqueKeyFieldName $field}} map[{{$.Exporter.GetEntryFieldType $field}}]*{{$entryStructName}} // mapping by {{$.Exporter.GetFieldName $field.Field}}
	{{- end}}
	{{- end}}
	{{- range $index, $ck := .Table.CompositeKeys -}}
		{{"\n"}}{{$.Exporter.GetTableCompositeKeyFieldName $ck}} {{$.Exporter.GetTableCompositeKeyFieldType $.Table $ck}} // composite-key {{$ck.Name}}
	{{- end}}
	{{- range $index, $group := .Table.Groups -}}
		{{"\n"}}{{$.Exporter.GetTableGroupFieldName $group}} {{$.Exporter.GetTableGroupFieldType $.Table $group}} // group {{$group.Name}}
	{{- end}}
}

func (t *{{.Exporter.GetTableStructName .Table}}) List() []*{{$entryStructName}} { return t.entries }

{{$hasUnique := false -}}
{{range $index, $field := .Table.Fields -}}
{{if $field.Unique -}}
{{if $hasUnique}}{{"\n"}}{{end -}}
{{$hasUnique = true -}}
{{$.Exporter.GenTableUniqueKeyMethod $.Table $field}}
{{- end}}
{{- end}}

{{range $index, $ck := .Table.CompositeKeys -}}
{{if $index}}{{"\n"}}{{end -}}
{{$.Exporter.GenTableCompositeKeyMethod $.Table $ck}}
{{- end}}

{{range $index, $group := .Table.Groups -}}
{{if $index}}{{"\n"}}{{end -}}
{{$.Exporter.GenTableGroupMethod $.Table $group}}
{{- end}}

func (t *{{$tableStructName}}) name() string {
	return "{{.Exporter.GetTableName .Table}}"
}

{{.Exporter.GenTableLoadDataMethod .Table}}

func (t *{{$tableStructName}}) init() {
	{{$hasUnique := false -}}
	{{range $index,$field := .Table.Fields -}}
	{{if $field.Unique -}}
	{{if $hasUnique}}{{"\n"}}{{end -}}
	{{$hasUnique = true -}}
	t.{{$.Exporter.GetTableUniqueKeyFieldName $field}} = make(map[{{$.Exporter.GetEntryFieldType $field}}]*{{$entryStructName}}, len(t.entries))
	{{- end}}
	{{- end}}
	for _, e := range t.entries {
		{{$hasUnique := false -}}
		{{range $index, $field := .Table.Fields -}}
		{{if $field.Unique -}}
		{{if $hasUnique}}{{"\n"}}{{end -}}
		{{$hasUnique = true -}}
		t.{{$.Exporter.GetTableUniqueKeyFieldName $field}}[e.{{$.Exporter.GetEntryFieldName $field}}] = e
		{{- end}}
		{{- end}}
		{{- range $index, $ck := .Table.CompositeKeys -}}
		{{"\n" -}}
		t.{{$.Exporter.GenTableCompositeKeyInitMethodName $ck}}(e)
		{{- end}}
		{{- range $index, $group := .Table.Groups -}}
		{{"\n" -}}
		t.{{$.Exporter.GenTableGroupInitMethodName $group}}(e)
		{{- end}}
	}	
}

{{range $index, $ck := .Table.CompositeKeys -}}
{{if $index}}{{"\n"}}{{end -}}
{{$.Exporter.GenTableCompositeKeyInitMethod $.Table $ck}}
{{- end}}

{{range $index, $group := .Table.Groups -}}
{{if $index}}{{"\n"}}{{end -}}
{{$.Exporter.GenTableGroupInitMethod $.Table $group}}
{{- end}}

func new{{$tableStructName}}() *{{$tableStructName}} {
	return &{{$tableStructName}} {
		{{$hasUnique := false -}}
		{{range $index, $field := .Table.Fields -}}
		{{if $field.Unique -}}
		{{if $hasUnique}}{{"\n"}}{{end -}}
		{{$hasUnique = true -}}
		{{$.Exporter.GetTableUniqueKeyFieldName $field}}: map[{{$.Exporter.GetEntryFieldType $field}}]*{{$entryStructName}}{},
		{{- end}}
		{{- end}}
		{{- range $index, $ck := .Table.CompositeKeys -}}
		{{"\n" -}}
		{{$.Exporter.GetTableCompositeKeyFieldName $ck}}: {{$.Exporter.GetTableCompositeKeyFieldType $.Table $ck}}{},
		{{- end}}
		{{- range $index, $group := .Table.Groups -}}
		{{"\n" -}}
		{{$.Exporter.GetTableGroupFieldName $group}}: {{$.Exporter.GetTableGroupFieldType $.Table $group}}{},
		{{- end}}
	}
}
`))

// GenNormalTableFile 生成go常规配置表代码文本
func (e *goExporter) GenNormalTableFile(td *parse.Table) string {
	var sb strings.Builder
	if err := templateGoNormalTableFile.Execute(&sb, map[string]interface{}{
		"Exporter": e,
		"Table":    td,
		"PkgName":  e.kindOptions.PkgName,
	}); err != nil {
		panic(pkg_errors.WithMessage(err, "export code: go: GenNormalTableFile"))
	}
	return sb.String()
}

// templateGoGlobalTableFile go全局配置表文件模版
var templateGoGlobalTableFile = template.Must(template.New("go_global_table_file").
	Parse(`// Code generated by gexcels; DO NOT EDIT.
// This file was automatically generated and may be overwritten.

package {{.PkgName}}

{{$tableStructName := .Exporter.GetTableStructName .Table -}}
// {{$tableStructName}} {{.Table.Desc}}
type {{$tableStructName}} struct {
	{{range $index, $field := .Table.Fields -}}
	{{if $index}}{{"\n"}}{{end -}}
	{{$.Exporter.GenTableStructField $field}}
	{{- end}}
}

func (t *{{$tableStructName}}) name() string {
  	return "{{.Exporter.GetTableName .Table}}"
}

{{.Exporter.GenTableLoadDataMethod .Table}}

func new{{$tableStructName}}() *{{$tableStructName}} {
	return &{{$tableStructName}}{}
}
`))

// GenGlobalTableFile 生成go全局配置表代码文本
func (e *goExporter) GenGlobalTableFile(td *parse.Table) string {
	var sb strings.Builder
	if err := templateGoGlobalTableFile.Execute(&sb, map[string]interface{}{
		"Exporter": e,
		"Table":    td,
		"PkgName":  e.kindOptions.PkgName,
	}); err != nil {
		panic(pkg_errors.WithMessage(err, "export code: go: GenGlobalTableFile"))
	}
	return sb.String()
}

// templateGoTableMgrFile go配置表管理器文件模版
var templateGoTableMgrFile = template.Must(template.New("go_table_mgr_file").
	Parse(`// Code generated by gexcels; DO NOT EDIT.
// This file was automatically generated and may be overwritten.

package {{.PkgName}}

import (
	"errors"
	"fmt"
	"github.com/godyy/gexcels"
	pkg_errors "github.com/pkg/errors"
	"io/fs"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"sync/atomic"
	"unsafe"
)

// tagMap 标签映射
// key 为标签值
// value 为标签优先级, 值越小优先级越高
type tagMap map[gexcels.Tag]int

// match 匹配标签
func (tm *tagMap) match(tag gexcels.Tag) bool {
	_, ok := (*tm)[gexcels.TagAny]
	if !ok {
		_, ok = (*tm)[tag]
	}
	return ok
}

// compareTag 比较 tag1 和 tag2，返回 tag1 的优先级是否高于 tag2
func (tm *tagMap) compareTag(tag1, tag2 gexcels.Tag) bool {
	i1, ok1 := (*tm)[tag1]
	i2, ok2 := (*tm)[tag2]
	if ok1 && ok2 {
		return i1 < i2
	}
	if ok1 {
		return true
	}
	if ok2 {
		return false
	}
	return strings.Compare(string(tag1), string(tag2)) > 0
}

// createTagMap 创建标签映射
// 当同一标签重复指定时，以优先级最高者为准
func createTagMap(tags []gexcels.Tag) (tagMap, error) {
	tm := make(tagMap, len(tags))
	for i, tag := range tags {
		if !tag.Valid() {
			return nil, fmt.Errorf("test: tag %s invalid", tag)
		}
		if _, ok := tm[tag]; ok {
			continue
		}
		tm[tag] = i
	}
	if len(tm) == 0 {
		tm[gexcels.TagEmpty] = 0
	}
	return tm, nil
}

// tableFileNameRegexp 表文件名正则表达式
var tableFileNameRegexp = regexp.MustCompile(` + "`(" + gexcels.NamePattern + `)(?:\.(` + gexcels.TagPattern + `))?` + "`" + `)

// parseTableFileName 解析配置表文件名
func parseTableFileName(fileName string) (string, gexcels.Tag, error) {
	matches := tableFileNameRegexp.FindStringSubmatch(fileName)
	if len(matches) != 3 {
		return "", "", fmt.Errorf("table file name %s invalid", fileName)
	}
	if !gexcels.Tag(matches[2]).Valid() {
		return "", "", fmt.Errorf("table file name %s tag invalid", fileName)
	}
	return matches[1], gexcels.Tag(matches[2]), nil
}

// {{.ExportedManagerName}} 配置表管理器
type {{.ExportedManagerName}} struct {
	*{{.ManagerName}}
}

func New{{.ExportedManagerName}}() *{{.ExportedManagerName}} {
	return &{{.ExportedManagerName}}{}
}

func (m *{{.ExportedManagerName}}) set(mm *{{.ManagerName}}) {
	atomic.StorePointer((*unsafe.Pointer)(unsafe.Pointer(&m.{{.ManagerName}})), unsafe.Pointer(mm))
}

// tableDataInfo 配置表数据
type tableDataInfo struct {
	filename string      // 文件名
	data     []byte      // 数据
	tag      gexcels.Tag // 标签
}

// ReloadData 重载所有数据
func (m *{{.ExportedManagerName}}) ReloadData(data map[string][]byte, tags ...gexcels.Tag) error {
	if len(data) == 0 {
		return errors.New("test: there is nothing to reload")
	}

	tagMap, err := createTagMap(tags)
	if err != nil {
		return err
	}

	mm := new{{.ManagerName}}()
	tables := registerTables(mm)
	tableDatas := make(map[string]*tableDataInfo)

	for fileName, data := range data {
		tableName, tag, err := parseTableFileName(fileName)
		if err != nil {
			return pkg_errors.WithMessage(err, "test")
		}

		if !tagMap.match(tag) {
			continue
		}

		if table := tables[tableName]; table == nil {
			return fmt.Errorf("test: table[%s] not exist", tableName)
		}

		if tableData := tableDatas[tableName]; tableData == nil {
			tableData = &tableDataInfo{
				filename: fileName,
				data:     data,
				tag:      tag,
			}
			tableDatas[tableName] = tableData
		} else if tagMap.compareTag(tag, tableData.tag) {
			tableData.filename = fileName
			tableData.data = data
			tableData.tag = tag
		}
	}

	for tableName, tableData := range tableDatas {
		table := tables[tableName]
		if err := table.loadData(tableData.data); err != nil {
			return pkg_errors.WithMessagef(err, "test: load table[%s] data", tableData.filename)
		}
	}

	m.set(mm)
	return nil
}

// tableFileInfo 配置表文件
type tableFileInfo struct {
	path string      // 路径
	tag  gexcels.Tag // 标签
}

// ReloadDir 从文件夹重载数据
func (m *{{.ExportedManagerName}}) ReloadDir(dir string, tags ...gexcels.Tag) error {
	tagMap, err := createTagMap(tags)
	if err != nil {
		return err
	}

	mm := new{{.ManagerName}}()
	tables := registerTables(mm)
	tableFiles := make(map[string]*tableFileInfo)

	ext := "{{.Ext}}"
	if err := filepath.Walk(dir, func(path string, info fs.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if info.IsDir() || filepath.Ext(info.Name()) != ext {
			return nil
		}

		fileName := strings.TrimSuffix(filepath.Base(path), ext)
		tableName, tag, err := parseTableFileName(fileName)
		if err != nil {
			return err
		}

		if !tagMap.match(tag) {
			return nil
		}

		if table := tables[tableName]; table == nil {
			return fmt.Errorf("table[%s] not exist", tableName)
		}

		if tableFile := tableFiles[tableName]; tableFile == nil {
			tableFile = &tableFileInfo{
				path: path,
				tag:  tag,
			}
			tableFiles[tableName] = tableFile
		} else if tagMap.compareTag(tag, tableFile.tag) {
			tableFile.path = path
			tableFile.tag = tag
		}

		return nil
	}); err != nil {
		return pkg_errors.WithMessage(err, "test")
	}

	for tableName, tableFile := range tableFiles {
		data, err := os.ReadFile(tableFile.path)
		if err != nil {
			return pkg_errors.WithMessagef(err, "read table file [%s]", tableName)
		}
		table := tables[tableName]
		if err := table.loadData(data); err != nil {
			return pkg_errors.WithMessagef(err, "load table file [%s] data", tableName)
		}
	}

	m.set(mm)
	return nil
}

// table 配置表接口抽象
type table interface{
	name() string 				// 配置表名
	loadData(data []byte) error // 数据加载
}

// {{.ManagerName}} 封装管理器数据
type {{.ManagerName}} struct {
	{{range $index, $table := .Tables -}}
	{{if $index}}{{"\n"}}{{end -}}
	{{$.Exporter.GenMgrTableFieldName $table}} *{{$.Exporter.GetTableStructName $table}} // {{$table.Desc}}
	{{- end}}
}

func new{{.ManagerName}}() *{{.ManagerName}} {
	return new({{.ManagerName}})
}

{{range $index, $table := .Tables -}}
{{if $index}}{{"\n"}}{{end -}}
{{$methodName := $.Exporter.GenMgrTableMethodName $table -}}
// {{$methodName}} {{$table.Desc}}
func (m *{{$.ManagerName}}) {{$methodName}}() *{{$.Exporter.GetTableStructName $table}} { return m.{{$.Exporter.GenMgrTableFieldName $table}} }
{{- end}}

// registerTables 注册配置表
func registerTables(m *{{.ManagerName}}) map[string]table {
	tables := make(map[string]table, {{len .Tables}})
	{{range $index, $table := .Tables -}}
	{{if $index}}{{"\n"}}{{end -}}
	// {{$table.Desc -}}
	{{$fieldName := $.Exporter.GenMgrTableFieldName $table}}
	m.{{$fieldName}} = new{{$.Exporter.GetTableStructName $table}}()
	tables[m.{{$fieldName}}.name()] = m.{{$fieldName}}
	{{- end}}
	return tables
}
`))

// GenTableMgrFile 生成go配置表管理器代码文本
func (e *goExporter) GenTableMgrFile() string {
	var sb strings.Builder
	if err := templateGoTableMgrFile.Execute(&sb, map[string]interface{}{
		"Exporter":            e,
		"PkgName":             e.kindOptions.PkgName,
		"ExportedManagerName": e.options.TableManagerName,
		"Tables":              e.parser.Tables,
		"Ext":                 "." + e.options.DataKind.String(),
		"ManagerName":         utils.CamelCase(e.options.TableManagerName),
	}); err != nil {
		panic(pkg_errors.WithMessage(err, "export code: go: GenTableMgrFile"))
	}
	return sb.String()
}

// templateGoNormalTableLoadJson go常规配置表json加载模版
var templateGoNormalTableLoadJson = template.Must(template.New("go_normal_table_load_json").
	Parse(`// loadData 加载json
func (t *{{.Exporter.GetTableStructName .Table}}) loadData(data []byte) error {
	if err := loadHelper.decodeJson(data, &t.entries); err != nil {
		return err
	}
	t.init()
	return nil
}`))

// GenNormalTableLoadJson 生成go常规配置表json加载代码
func (e *goExporter) GenNormalTableLoadJson(td *parse.Table) string {
	var sb strings.Builder
	if err := templateGoNormalTableLoadJson.Execute(&sb, map[string]interface{}{
		"Exporter": e,
		"Table":    td,
	}); err != nil {
		panic(pkg_errors.WithMessage(err, "export code: go: GenNormalTableLoadJson"))
	}
	return sb.String()
}

// templateGoGlobalTableLoadJson go全局配置表json加载模版
var templateGoGlobalTableLoadJson = template.Must(template.New("go_global_table_load_json").
	Parse(`// loadData 加载json
func (t *{{.Exporter.GetTableStructName .Table}}) loadData(data []byte) error {
	return loadHelper.decodeJson(data, t)
}`))

// GenGlobalTableLoadJson 生成go全局配置表json加载代码
func (e *goExporter) GenGlobalTableLoadJson(td *parse.Table) string {
	var sb strings.Builder
	if err := templateGoGlobalTableLoadJson.Execute(&sb, map[string]interface{}{
		"Exporter": e,
		"Table":    td,
	}); err != nil {
		panic(pkg_errors.WithMessage(err, "export code: go: GenGlobalTableLoadJson"))
	}
	return sb.String()
}

// templateGoJsonLoadHelperFile go配置表json加载帮助代码文件模版
var templateGoJsonLoadHelperFile = template.Must(template.New("go_json_load_helper_file").
	Parse(`// Code generated by gexcels; DO NOT EDIT.
// This file was automatically generated and may be overwritten.

package {{.PkgName}}

import (
	"encoding/json"
)

type jsonLoadHelper struct{}

var loadHelper = &jsonLoadHelper{}

func (jh *jsonLoadHelper) decodeJson(data []byte, v interface{}) error {
	return json.Unmarshal(data, v)
}
`))

// GenJsonLoadHelperFile 生成go配置表json加载帮助代码
func (e *goExporter) GenJsonLoadHelperFile() string {
	var sb strings.Builder
	if err := templateGoJsonLoadHelperFile.Execute(&sb, map[string]interface{}{
		"PkgName": e.kindOptions.PkgName,
	}); err != nil {
		panic(pkg_errors.WithMessage(err, "export code: go: GenJsonLoadHelperFile"))
	}
	return sb.String()
}

// templateGoNormalLoadBytes go常规配置表bytes加载模版
var templateGoNormalLoadBytes = template.Must(template.New("go_normal_table_load_bytes").
	Parse(`// loadData 加载bytes
func (t *{{.Exporter.GetTableStructName .Table}}) loadData(data []byte) error {
	if err := loadHelper.decodeEntries(data, &t.entries); err != nil {
		return err
	}
	t.init()
	return nil
}`))

// GenNormalTableLoadBytes 生成go常规配置表bytes加载代码
func (e *goExporter) GenNormalTableLoadBytes(td *parse.Table) string {
	var sb strings.Builder
	if err := templateGoNormalLoadBytes.Execute(&sb, map[string]interface{}{
		"Exporter": e,
		"Table":    td,
	}); err != nil {
		panic(pkg_errors.WithMessage(err, "export code: go: GenNormalTableLoadBytes"))
	}
	return sb.String()
}

// templateGoGlobalLoadBytes go全局配置表bytes加载模版
var templateGoGlobalLoadBytes = template.Must(template.New("go_global_table_load_bytes").
	Parse(`// loadData 加载bytes
func (t *{{.Exporter.GetTableStructName .Table}}) loadData(data []byte) error {
	return loadHelper.decodeGlobal(data, t)
}`))

// GenGlobalTableLoadBytes 生成go全局配置表bytes加载代码
func (e *goExporter) GenGlobalTableLoadBytes(td *parse.Table) string {
	var sb strings.Builder
	if err := templateGoGlobalLoadBytes.Execute(&sb, map[string]interface{}{
		"Exporter": e,
		"Table":    td,
	}); err != nil {
		panic(pkg_errors.WithMessage(err, "export code: go: GenGlobalTableLoadBytes"))
	}
	return sb.String()
}

// templateGoBytesLoadHelperFile go配置表bytes加载帮助代码文件模版
var templateGoBytesLoadHelperFile = template.Must(template.New("go_bytes_load_helper_file").
	Parse(`// Code generated by gexcels; DO NOT EDIT.
// This file was automatically generated and may be overwritten.

package {{.PkgName}}

import (
	"bufio"
	"encoding/base64"
	"errors"
	"fmt"
	"io"
	"reflect"
	"github.com/godyy/gutils/buffer/bytes"
	pkg_errors "github.com/pkg/errors"
)

var loadHelper = &bytesLoadHelper{}

type bytesLoadHelper struct{}

func (bh *bytesLoadHelper) decodeFieldIndex(buf *bytes.Buffer) (int16, error) {
	return buf.ReadVarint16()
}

func (bh *bytesLoadHelper) loadLine(dataBuf *bufio.Reader, lineBuf *bytes.Buffer) error {
	var (
		line, l  []byte
		isPrefix bool
		err      error
	)
	for {
		l, isPrefix, err = dataBuf.ReadLine()
		if err != nil {
			return err
		}
		if isPrefix {
			line = append(line, l...)
		} else {
			if line == nil {
				line = l
			} else {
				line = append(line, l...)
			}
			break
		}
	}
	line, err = base64.StdEncoding.DecodeString(string(line))
	if err != nil {
		return err
	}
	lineBuf.SetBuf(line)
	return nil
}

func (bh *bytesLoadHelper) decodeEntries(data []byte, val interface{}) error {
	var (
		dataBuf = bufio.NewReader(bytes.NewBuffer(data))
		lineBuf bytes.Buffer
	)

	if err := bh.loadLine(dataBuf, &lineBuf); err != nil {
		if errors.Is(err, io.EOF) {
			return nil
		}
		return pkg_errors.WithMessage(err, "load entry count line")
	}

	n, err := lineBuf.ReadVarint32()
	if err != nil {
		return pkg_errors.WithMessage(err, "load entry count")
	}

	if n == 0 {
		return nil
	}

	v := reflect.ValueOf(val).Elem()
	arrayType := v.Type()
	entryType := arrayType.Elem()
	entryArray := reflect.MakeSlice(arrayType, 0, int(n))
	for i := int32(0); i < n; i++ {
		if err := bh.loadLine(dataBuf, &lineBuf); err != nil {
			return pkg_errors.WithMessagef(err, "load entry[%d] line", i)
		}
		entry := reflect.New(entryType.Elem())
		if err := bh.decodeValue(&lineBuf, entry.Elem()); err != nil {
			return pkg_errors.WithMessagef(err, "load entry[%d]", i)
		}
		entryArray = reflect.Append(entryArray, entry)
	}
	v.Set(entryArray)

	return nil
}

func (bh *bytesLoadHelper) decodeGlobal(data []byte, val interface{}) error {
	var (
		dataBuf = bufio.NewReader(bytes.NewBuffer(data))
		lineBuf bytes.Buffer
	)

	v := reflect.ValueOf(val).Elem()
	n := v.NumField()
	i := 0
	for {
		if err := bh.loadLine(dataBuf, &lineBuf); err != nil {
			if errors.Is(err, io.EOF) {
				break
			}
			return pkg_errors.WithMessagef(err, "load line[%d]", i)
		}
		index, err := bh.decodeFieldIndex(&lineBuf)
		if err != nil {
			return pkg_errors.WithMessage(err, "load field index")
		}
		field := v.Field(int(index - 1))
		if err := bh.decodeValue(&lineBuf, field); err != nil {
			return pkg_errors.WithMessagef(err, "load field[%d]", index-1)
		}
		i++
		if int(index) >= n {
			break
		}
	}

	return nil
}

func (bh *bytesLoadHelper) decodeValue(buf *bytes.Buffer, v reflect.Value) (err error) {
	switch v.Kind() {
	case reflect.Int32: // FTInt32
		var i32 int32
		i32, err = buf.ReadVarint32()
		if err == nil {
			v.SetInt(int64(i32))
		}
	case reflect.Int64: // FTInt64
		var i64 int64
		i64, err = buf.ReadVarint64()
		if err == nil {
			v.SetInt(i64)
		}
	case reflect.Float32: // FTFloat32
		var f32 float32
		f32, err = buf.ReadFloat32()
		if err == nil {
			v.SetFloat(float64(f32))
		}
	case reflect.Float64: // FTFloat64
		var f64 float64
		f64, err = buf.ReadFloat64()
		if err == nil {
			v.SetFloat(f64)
		}
	case reflect.Bool: // FTBool
		var b bool
		b, err = buf.ReadBool()
		if err == nil {
			v.SetBool(b)
		}
	case reflect.String: // FTString
		var s string
		s, err = buf.ReadString()
		if err == nil {
			v.SetString(s)
		}
	case reflect.Ptr, reflect.Struct: // FTStruct
		err = bh.decodeStruct(buf, v)
	case reflect.Slice: // FTArray
		err = bh.decodeArray(buf, v)
	default:
		panic(fmt.Sprintf("bytesLoadHelper: decodeValue: unsupported value: %v", v.String()))
	}
	return err
}

func (bh *bytesLoadHelper) decodeStruct(buf *bytes.Buffer, s reflect.Value) error {
	var (
		v     reflect.Value
		index int16
		err   error
	)

	if s.Kind() == reflect.Ptr {
		ptr := reflect.New(s.Type().Elem())
		v = ptr.Elem()
		s.Set(ptr)
	} else {
		v = s
	}

	n := v.NumField()
	for {
		index, err = bh.decodeFieldIndex(buf)
		if err != nil {
			if err == io.EOF {
				break
			}
			return pkg_errors.WithMessage(err, "load field index")
		}
		if index == 0 {
			break
		}
		field := v.Field(int(index - 1))
		if err = bh.decodeValue(buf, field); err != nil {
			return pkg_errors.WithMessagef(err, "load field[%d]", index)
		}
		if int(index) >= n {
			break
		}
	}

	return nil
}

func (bh *bytesLoadHelper) decodeArrayLength(buf *bytes.Buffer) (int, error) {
	arrayLen, err := buf.ReadVarint16()
	if err != nil {
		return 0, pkg_errors.WithMessage(err, "load array length")
	}
	return int(arrayLen), nil
}

func (bh *bytesLoadHelper) decodeArray(buf *bytes.Buffer, array reflect.Value) error {
	elementType := array.Type().Elem()
	arrayLen, err := bh.decodeArrayLength(buf)
	if err != nil {
		return err
	}
	if arrayLen == 0 {
		return nil
	}
	arrayValue := reflect.MakeSlice(array.Type(), 0, arrayLen)
	for i := 0; i < arrayLen; i++ {
		elementPtr := reflect.New(elementType)
		element := elementPtr.Elem()
		if err := bh.decodeValue(buf, element); err != nil {
			return pkg_errors.WithMessagef(err, "load array[%d]", i)
		}
		arrayValue = reflect.Append(arrayValue, element)
	}
	array.Set(arrayValue)
	return nil
}
`))

// GenBytesLoadHelperFile 生成go配置表bytes加载帮助代码文件
func (e *goExporter) GenBytesLoadHelperFile() string {
	var sb strings.Builder
	if err := templateGoBytesLoadHelperFile.Execute(&sb, map[string]interface{}{
		"PkgName": e.kindOptions.PkgName,
	}); err != nil {
		panic(pkg_errors.WithMessage(err, "export code: go: GenBytesLoadHelperFile"))
	}
	return sb.String()
}
